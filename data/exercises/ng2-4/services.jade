section
  :markdown
    A TypeScript service is just an exported TypeScript class. We define it in a file, then export it:

    ```
    @Injectable()
    export class CatService {
      getCats() {
        ['Manny', 'Francis', 'Terry Wogan'];
      }
    }
    ```

    The @injectable decorator at the top is a blank decorator. It's only purpose is to trick TypeScript into storing type data about the object. The presence of a decorator means that type info might be required, so Angular holds onto it using Reflect.Metadata.


    We can then import this into a component like this:

    ```
    import { Component, OnInit } from '@angular/core';
    import { CatService } from './cats';

    @Component({
      selector: 'app',
      template:`
        {{cats | json}}
      `,
      providers: [CatService]
    })
    export class AppComponent implements OnInit {
      constructor(private catService: CatService) { }
      ngOnInit() {
        this.cats = this.catService.getCats();
      }
    }
    ```

    ## Dependency Injection

    Our Component receives a CatService, and yet we never manually made one. Angular has made one for us. We call this Dependency Injection.

    Notice the providers attribute of the component. This tells Angular to create an injector for this component, so the component can receive a CatService.

    Now notice the class constructor. It receives a catService of type CatService. This is enough for Angular to know that it must make a CatService and pass it in.

section.exercise
  :markdown
    ## Exercise - A Service

    Extend your ng-for exercise from earlier such that we pull the cat data from a service. Use ng-for to iterate over the list and output the cats.

section.exercise
  :markdown
    ## Exercise - testing

    Finally, we would like to be able to test our service. The Angular core team have put together a full and up-to-date guide on this. Follow the instructions here to set up a Karma test to run on it.

    <https://angular.io/docs/ts/latest/guide/webpack.html>
